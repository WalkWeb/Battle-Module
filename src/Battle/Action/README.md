# Action

Механика взаимодействия юнитов построена максимально абстрактно:

- Юниту, который совершает действие мы говорим «дай свой Action» - получаем ActionCollection и нам не важно, что там 
внутри
- Самому Action, мы говорим «обработайся» - и Action сам выбирает цель для применения - в случае удара это будет цель из 
вражеской команды, а в случае лечения - кто-то из своей команды
- Юниту, к которому применяется действие мы говорим «примени Action» и юнит сам, в зависимости от типа события применит
к себе удар, лечение или что-то другое

## Classes

- AbstractAction - абстрактный класс, который содержит в себе параметры и методы необходимые для работы всех типов 
Action
- ActionCollection - коллекция Action со строгой типизацией
- ActionInterface - описание общего интерфейса для всех Action
- DamageAction, HealAction EffectAction и прочие - конкретная реализация тех или иных типов Action

## Механика выбора цели

Выбор цели для применения события - не такая простая задача, какой может показаться на первый взгляд. Несмотря на то,
что кажется очевидным для DamageAction по умолчанию выбирать кого-то из противников, если DamageAction применяется
как эффект на юнита (например, отравление, которое каждый ход будет наносить юниту урон) - то применять событие нужно
на себя.

Для реализации этой логики добавлен обязательный для всех событий параметр `int $typeTarget`, именно он определяет,
по какой логике будет выбрана цель для применения события.

При этом, логика следующая:

1. $typeTarget задается через конструктор
2. Вызов метода Action::canByUsed() говорит о том, может ли сейчас способность быть применена.
3. Вызов метода Action::getTargetUnit() вернет цель, если событие уже было применено, и бросит исключение, если событие 
еще не применялось, и, соответственно, цель еще не выбрана. Если выбор цели будет делаться сразу, при создании события,
от этого исключения можно будет избавиться. Как и метод Action::canByUsed() будет просто проверять, есть ли цель
4. Вызов метода Action::handle() выбирает цель для применения и применяет к ней событие. Или бросает исключение, если 
цели нет

Итого, корректная цепочка работы с событием выглядит так:
1. Создали событие
2. Проверили, может ли событие быть применено
3. Выполнили событие
4. Получили цель события (для создания сообщения в чате, статистики, сценария)

Т.е. событие имеет два состояния: когда событие только создано, но цель для юнита не выбрана (и на этот момент еще 
непонятно, сможет ли событие примениться), и когда цель для применения выбрана. В этом случае событие может быть успешно
применено.

## Примечания

Был испробован вариант выбора цели сразу при создании Action, это казалось бы очевидно - потому что после создания
Action сразу применяется, плюс это избавит Action от двух состояний - когда цель выбрана или нет. Но, на практике сразу 
стали вылезать баги. Например, если юнит делает два удара за ход, а цель умерла после первого удара - юнит делает второй 
удар в эту же мертвую цель. Как раз из-за того, что для двух DamageAction сразу при создании была выбрана одна и также 
цель. Хотя правильно каждый раз искать цель для удара именно перед ударом.

## Другими словами

Другими словами о концепции Action - изменение объекта происходит не через строчку кода, например: 

`$unit->addEffect($effect)`

А через объект. И этот объект мы можем в одном месте создать, в другое место передать, и при определенном событии 
применить. Более того, с добавлением ActionFactory - изменение можно выразить в массиве, из которого в нужный момент
будет создан Action, и в нужный момент применен к юниту.

Это невероятным образом упрощает изменение сложных объектов - избавляя от необходимости думать «А нужно ли проверить, 
что юнит остался жив, после нанесения урона?», «А может ли юниту быть добавлен этот эффект?» и т.д.

Конечно, сами проверки никуда не исчезают, но думать о них при самом изменении юнита не нужно.

Также это упрощает взаимодействие между:

Unit <=> Unit
Ability => Unit
Effect => Unit

А если бы логика затрагивала не только бой, а и всю игровую логику:

Spells => Unit
Item (например, зелье) => Unit
World (например, ловушка) => Unit

Тем самым Action становится универсальным и удобным способом воздействовать на юнита из других объектов.
