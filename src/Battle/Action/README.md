# Action

Механика взаимодействия юнитов построена максимально абстрактно:

- Юниту, который совершает действие мы говорим «дай свой Action» - получаем ActionCollection и нам не важно, что там 
внутри
- Самому Action, мы говорим «обработайся» - и Action сам выбирает цель для применения - в случае удара это будет цель из 
вражеской команды, а в случае лечения - кто-то из своей команды
- Юниту, к которому применяется действие мы говорим «примени Action» и юнит сам, в зависимости от типа события применит
к себе удар, лечение или что-то другое

## Classes

- AbstractAction - абстрактный класс, который содержит в себе параметры и методы необходимые для работы всех типов 
Action
- ActionCollection - коллекция Action со строгой типизацией
- ActionInterface - описание общего интерфейса для всех Action
- DamageAction, HealAction EffectAction и прочие - конкретная реализация тех или иных типов Action

## Механика выбора цели

Выбор цели для применения события - не такая простая задача, какой может показаться на первый взгляд. Несмотря на то,
что кажется очевидным для DamageAction по умолчанию выбирать кого-то из противников, если DamageAction применяется
как эффект на юнита (например, отравление, которое каждый ход будет наносить юниту урон) - то применять событие нужно
на себя.

Для реализации этой логики добавлен обязательный для всех событий параметр `int $typeTarget`, именно он определяет,
по какой логике будет выбрана цель для применения события.

При этом, логика следующая:

1. $typeTarget задается через конструктор. Так как подразумевается, что после создания Action будет применен - сразу 
в конструкторе проверяется наличие цели для применения
2. Вызов метода Action::canByUsed() говорит о том, может ли сейчас способность быть применена. Для большинства Action 
просто делается проверка на наличие цели, для EffectAction дополнительно проверяется, есть ли аналогичный эффект на цели
3. Вызов метода Action::getTargetUnit() вернет цель, если она есть, или бросит исключение, если её нет.
4. Вызов метода Action::handle() применяет к цели событие (себя), юнит уже сам разберется, как обработать переданный
Action. Если цели нет - будет брошено исключение. В работе Action::handle() есть две особенности - SummonAction помимо
юнита затрагивает команду - добавляя в неё юнит, а в WaitAction событие всегда применяется к себе, и ситуации, когда
цели нет в нем быть не может.

Итого, корректная цепочка работы с событием выглядит так:
1. Создали событие
2. Проверили, может ли событие быть применено
3. Выполнили событие
4. Получили цель события (для создания сообщения в чате, статистики, сценария)

## TODO

- Сделать ActionFactory, которая по множеству параметров будет создавать соответствующие Actions 

