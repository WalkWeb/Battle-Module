# Action

Механика взаимодействия юнитов построена максимально абстрактно:

- Юниту, который совершает действие мы говорим «дай свой Action» - получаем ActionCollection и нам не важно, что там 
внутри
- Самому Action, мы говорим «обработайся» - и Action сам выбирает цель для применения - в случае удара это будет цель из 
вражеской команды, а в случае лечения - кто-то из своей команды
- Юниту, к которому применяется действие мы говорим «примени Action» и юнит сам, в зависимости от типа события применит
к себе удар, лечение или что-то другое

## Classes

- AbstractAction - абстрактный класс, который содержит в себе параметры и методы необходимые для работы всех типов 
Action
- ActionCollection - коллекция Action со строгой типизацией
- ActionInterface - описание общего интерфейса для всех Action
- DamageAction, HealAction EffectAction и прочие - конкретная реализация тех или иных типов Action

## Механика выбора цели

Выбор цели для применения события - не такая простая задача, какой может показаться на первый взгляд. Несмотря на то,
что кажется очевидным для DamageAction по умолчанию выбирать кого-то из противников, если DamageAction применяется
как эффект на юнита (например, отравление, которое каждый ход будет наносить юниту урон) - то применять событие нужно
на себя.

Для реализации этой логики добавлен обязательный для всех событий параметр `int $typeTarget`, именно он определяет,
по какой логике будет выбрана цель для применения события.

При этом, логика следующая:

1. $typeTarget задается через конструктор
2. Вызов метода Action::canByUsed() говорит о том, может ли сейчас способность быть применена.
3. Вызов метода Action::getTargetUnit() вернет цель, если событие уже было применено, и бросит исключение, если событие 
еще не применялось, и, соответственно, цель еще не выбрана. Если выбор цели будет делаться сразу, при создании события,
от этого исключения можно будет избавиться. Как и метод Action::canByUsed() будет просто проверять, есть ли цель
4. Вызов метода Action::handle() выбирает цель для применения и применяет к ней событие. Или бросает исключение, если 
цели нет

Итого, корректная цепочка работы с событием выглядит так:
1. Создали событие
2. Проверили, может ли событие быть применено
3. Выполнили событие
4. Получили цель события (для создания сообщения в чате, статистики, сценария)

Т.е. событие имеет два состояния: когда событие только создано, но цель для юнита не выбрана (и на этот момент еще 
непонятно, сможет ли событие примениться), и когда цель для применения выбрана. В этом случае событие может быть успешно
применено.

## TODO

- Сделать ActionFactory, которая по множеству параметров будет создавать соответствующие Actions 
- В будущем нужно будет подумать над темой того, стоит ли в момент создания события определять цель и возможность 
применения события. С одной стороны, это избавит от необходимости думать о двух неочевидных состояниях события, с другой
может приводить к багам, когда на момент создания события цели еще нет (например, никто не ранен), но к моменту 
применения события цель появилась - а событие думает, что оно примениться не может.
- Подумать над изменением механики метода Action::canByUsed() - каждый раз делать фактическую проверку (хотя до конца не
понятно, в каких ситуациях при текущей механики могут возникнуть сложности)
